//---------16 x 8 DRAM (Behavioral Model)---------//
module dram (
    input we,             // write enable
    input en,             // chip enable
    input clk,            // clock for refresh
    input [3:0] addr,     // 4-bit address
    inout [7:0] data
);

    reg [7:0] mem [15:0];   // memory array
    reg [7:0] refresh_mem [15:0]; // backup refresh array

    // Write operation
    always @(*) begin
        if (en && we) begin
            mem[addr] = data;
        end
    end

    // Read operation
    assign data = (en && !we) ? mem[addr] : 8'hZZ;

    // Simple Refresh logic (every clock copy backup)
    always @(posedge clk) begin
        refresh_mem <= mem;   // pretend refresh is happening
    end

endmodule

//-----------testbench------------------//
`timescale 1ns/1ps
module dram_tb;

    reg we, en, clk;
    reg [3:0] addr;
    reg [7:0] tempd;
    wire [7:0] data;
    integer i;

    // Instantiate DRAM
    dram DUT (
        .we(we),
        .en(en),
        .clk(clk),
        .addr(addr),
        .data(data)
    );

    // Drive data bus during write
    assign data = (we && en) ? tempd : 8'hZZ;

    // Clock gen
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    initial begin
        $dumpfile("dram.vcd");
        $dumpvars(0, dram_tb);

        // Write Phase
        en = 1; we = 1;
        for (i = 0; i < 16; i = i + 1) begin
            addr = i;
            tempd = i + 8'hA0;   // store values A0, A1, ...
            #10;
        end

        // Read Phase
        en = 1; we = 0;
        for (i = 0; i < 16; i = i + 1) begin
            addr = i;
            #10;
            $display("Read addr=%0d => data=%h", addr, data);
        end

        #20 $finish;
    end

endmodule

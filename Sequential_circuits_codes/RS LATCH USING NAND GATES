//================ RS LATCH USING NAND GATES =================

//================ DATAFLOW MODEL =================
/*
module rs_latch_nand(input R, S, output Q, Qbar);
  assign Q    = ~(R & Qbar);  // NAND logic
  assign Qbar = ~(S & Q);     // Cross-coupled NAND
endmodule
*/

//================ BEHAVIORAL MODEL =================
/*
module rs_latch_nand(input R, S, output reg Q, Qbar);
  always @(*) begin
    if(R==0 && S==0) begin
      Q = Q; Qbar = Qbar;      // Hold
    end
    else if(R==0 && S==1) begin
      Q = 1; Qbar = 0;         // Set
    end
    else if(R==1 && S==0) begin
      Q = 0; Qbar = 1;         // Reset
    end
    else begin
      Q = 1'bx; Qbar = 1'bx;   // Invalid (R=1, S=1 for NAND latch)
    end
  end
endmodule
*/

//================ STRUCTURAL MODEL =================
/*
module rs_latch_nand(input R, S, output Q, Qbar);
  nand n1(Q, R, Qbar);   // NAND gate 1
  nand n2(Qbar, S, Q);   // NAND gate 2
endmodule
*/
                                        
//================  BEHAVIORAL MODEL(case statement)=================

module rs_latch_nand(input R, S, output reg Q, Qbar);
  always @(*) begin
    case ({R,S})
      2'b00: begin 
                Q = Q;      // Hold (no change)
                Qbar = Qbar;
             end
      2'b01: begin 
                Q = 1;      // Set
                Qbar = 0;
             end
      2'b10: begin 
                Q = 0;      // Reset
                Qbar = 1;
             end
      2'b11: begin 
                Q = 1'bx;   // Invalid condition
                Qbar = 1'bx;
             end
    endcase
  end
endmodule

//================ TESTBENCH =================
module tb_rs_latch_nand;
  reg R, S;
  wire Q, Qbar;

  rs_latch_nand dut(.R(R), .S(S), .Q(Q), .Qbar(Qbar));

  initial begin
    $dumpfile("rs_latch_nand.vcd");
    $dumpvars(0, tb_rs_latch_nand);
    $monitor("Time=%0t | R=%b S=%b | Q=%b Qbar=%b",
              $time, R, S, Q, Qbar);

    // Apply test cases
    R=0; S=0; #5;  // Hold
    R=0; S=1; #5;  // Set
    R=0; S=0; #5;  // Hold
    R=1; S=0; #5;  // Reset
    R=0; S=0; #5;  // Hold
    R=1; S=1; #5;  // Invalid
    $finish;
  end
endmodule
